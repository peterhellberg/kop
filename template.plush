// Code generated by oto; DO NOT EDIT.

package <%= def.PackageName %>

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
	"time"
	<%= for (importPath, name) in def.Imports { %>
	<%= name %> "<%= importPath %>"
	<% } %>
)

<%= for (service) in def.Services { %>
<%= format_comment_text(service.Comment) %>type <%= service.Name %> interface {
<%= for (method) in service.Methods { %>
	<%= format_comment_text(method.Comment) %><%= method.Name %>(context.Context, <%= method.InputObject.TypeName %>) (*<%= method.OutputObject.TypeName %>, error)<% } %>
}
<% } %>

<%= for (service) in def.Services { %>
type <%= camelize_down(service.Name) %>Server struct {
	server *Server
	<%= camelize_down(service.Name) %> <%= service.Name %>
}

// Register adds the <%= service.Name %> to the otohttp.Server.
func Register<%= service.Name %>(server *Server, <%= camelize_down(service.Name) %> <%= service.Name %>) {
	handler := &<%= camelize_down(service.Name) %>Server{
		server: server,
		<%= camelize_down(service.Name) %>: <%= camelize_down(service.Name) %>,
	}
	<%= for (method) in service.Methods { %>server.Register("<%= service.Name %>", "<%= method.Name %>", handler.handle<%= method.Name %>)
	<% } %>}
<%= for (method) in service.Methods { %>
func (s *<%= camelize_down(service.Name) %>Server) handle<%= method.Name %>(w http.ResponseWriter, r *http.Request) {
	var request <%= method.InputObject.TypeName %>
	if err := decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}

	response, err := s.<%= camelize_down(service.Name) %>.<%= method.Name %>(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	
  if err := encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}
<% } %>
<% } %>

<%= for (object) in def.Objects { %>
<%= format_comment_text(object.Comment) %>type <%= object.Name %> struct {
	<%= for (field) in object.Fields { %><%= format_comment_text(field.Comment) %><%= field.Name %> <%= if (field.Type.Multiple == true) { %>[]<% } %><%= field.Type.TypeName %> `json:"<%= field.NameLowerCamel %><%= if (field.OmitEmpty) { %>,omitempty<% } %>"`
<% } %>
}
<% } %>

// Server handles rpc requests.
type Server struct {
	// Basepath is the path prefix to match.
	// Default: /rpc/
	Basepath string

	routes map[string]http.Handler
	// NotFound is the http.Handler to use when a resource is
	// not found.
	NotFound http.Handler
	// OnErr is called when there is an error.
	OnErr func(w http.ResponseWriter, r *http.Request, err error)
}

// NewServer makes a new Server.
func NewServer() *Server {
	return &Server{
		Basepath: "/rpc/",
		routes:   make(map[string]http.Handler),
		OnErr: func(w http.ResponseWriter, r *http.Request, err error) {
			errObj := struct {
				Error string `json:"error"`
			}{
				Error: err.Error(),
			}
			if err := encode(w, r, http.StatusInternalServerError, errObj); err != nil {
				log.Printf("failed to encode error: %s\n", err)
			}
		},
		NotFound: http.NotFoundHandler(),
	}
}

// Register adds a handler for the specified service method.
func (s *Server) Register(service, method string, h http.HandlerFunc) {
	s.routes[fmt.Sprintf("%s%s.%s", s.Basepath, service, method)] = h
}

// ServeHTTP serves the request.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		s.NotFound.ServeHTTP(w, r)
		return
	}
	h, ok := s.routes[r.URL.Path]
	if !ok {
		s.NotFound.ServeHTTP(w, r)
		return
	}
	h.ServeHTTP(w, r)
}

func encode(w http.ResponseWriter, r *http.Request, status int, v interface{}) error {
	b, err := json.Marshal(v)
	if err != nil {
		return fmt.Errorf("encode json: %w", err)
	}

	var out io.Writer = w
	
  if strings.Contains(r.Header.Get("Accept-Encoding"), "gzip") {
		w.Header().Set("Content-Encoding", "gzip")
		gzw := gzip.NewWriter(w)
		out = gzw
		defer gzw.Close()
	}
	
  w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(status)
	
  if _, err := out.Write(b); err != nil {
		return err
	}
	
  return nil
}

func decode(r *http.Request, v interface{}) error {
	bodyBytes, err := io.ReadAll(io.LimitReader(r.Body, 1024*1024))
	if err != nil {
		return fmt.Errorf("decode: read body: %w", err)
	}
	
  err = json.Unmarshal(bodyBytes, v)
	if err != nil {
		return fmt.Errorf("decode: json.Unmarshal: %w", err)
	}
	
  return nil
}

type Client struct {
	Endpoint  string
	HTTPClient 	*http.Client
	BeforeRequest func(r *http.Request) error
}

func NewClient(endpoint string) *Client {
	c := &Client{
		Endpoint: endpoint,
		HTTPClient: &http.Client{Timeout:10*time.Second},
	}
	return c
}

<%= for (service) in def.Services { %>
<%= format_comment_text(service.Comment) %>type <%= service.Name %>Client struct {
	client *Client
}

// New<%= service.Name %> makes a new client for accessing <%= service.Name %> services.
func New<%= service.Name %>Client(client *Client) *<%= service.Name %>Client {
	return &<%= service.Name %>Client{
		client: client,
	}
}

<%= for (method) in service.Methods { %>
<%= format_comment_text(method.Comment) %>func (s *<%= service.Name %>Client) <%= method.Name %>(ctx context.Context, r <%= method.InputObject.TypeName %>) (*<%= method.OutputObject.TypeName %>, error) {
	data, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("%w: <%= service.Name %>.<%= method.Name %>: marshal <%= method.InputObject.TypeName %>", err)
	}

	rawurl := s.client.Endpoint + "<%= service.Name %>.<%= method.Name %>"

	req, err := http.NewRequest(http.MethodPost, rawurl, bytes.NewReader(data))
	if err != nil {
		return nil, fmt.Errorf("%w: <%= service.Name %>.<%= method.Name %>: NewRequest", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	
  req = req.WithContext(ctx)
	
  if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	
  resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("%w: <%= service.Name %>.<%= method.Name %>", err)
	}
	defer resp.Body.Close()
	
  var response struct {
		<%= method.OutputObject.TypeName %>
		Error string
	}
	
  var bodyReader io.Reader = resp.Body
	
  if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("%w: <%= service.Name %>.<%= method.Name %>: new gzip reader", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	
  respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("%w: <%= service.Name %>.<%= method.Name %>: read response body", err)
	}
	
  if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("<%= service.Name %>.<%= method.Name %>: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	
  if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	
  return &response.<%= method.OutputObject.TypeName %>, nil
}
<% } %>
<% } %>
