// Code generated by oto; DO NOT EDIT.

package rpc

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"time"
)

type List interface {
	Add(context.Context, AddRequest) (*AddResponse, error)
	Clear(context.Context, ClearRequest) (*ClearResponse, error)
	Items(context.Context, ItemsRequest) (*ItemsResponse, error)
	Remove(context.Context, RemoveRequest) (*RemoveResponse, error)
}

type listServer struct {
	server *Server
	list   List
}

// Register adds the List to the otohttp.Server.
func RegisterList(server *Server, list List) {
	handler := &listServer{
		server: server,
		list:   list,
	}
	server.Register("List", "Add", handler.handleAdd)
	server.Register("List", "Clear", handler.handleClear)
	server.Register("List", "Items", handler.handleItems)
	server.Register("List", "Remove", handler.handleRemove)
}

func (s *listServer) handleAdd(w http.ResponseWriter, r *http.Request) {
	var request AddRequest
	if err := decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}

	response, err := s.list.Add(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}

	if err := encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *listServer) handleClear(w http.ResponseWriter, r *http.Request) {
	var request ClearRequest
	if err := decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}

	response, err := s.list.Clear(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}

	if err := encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *listServer) handleItems(w http.ResponseWriter, r *http.Request) {
	var request ItemsRequest
	if err := decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}

	response, err := s.list.Items(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}

	if err := encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *listServer) handleRemove(w http.ResponseWriter, r *http.Request) {
	var request RemoveRequest
	if err := decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}

	response, err := s.list.Remove(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}

	if err := encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

type AddRequest struct {
	Items []string `json:"items"`
}

type AddResponse struct {
	Items []string `json:"items"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

type ClearRequest struct {
}

type ClearResponse struct {
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

type ItemsRequest struct {
}

type ItemsResponse struct {
	Items []string `json:"items"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

type RemoveRequest struct {
	Items []string `json:"items"`
}

type RemoveResponse struct {
	Items []string `json:"items"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// Server handles rpc requests.
type Server struct {
	// Basepath is the path prefix to match.
	// Default: /rpc/
	Basepath string

	routes map[string]http.Handler
	// NotFound is the http.Handler to use when a resource is
	// not found.
	NotFound http.Handler
	// OnErr is called when there is an error.
	OnErr func(w http.ResponseWriter, r *http.Request, err error)
}

// NewServer makes a new Server.
func NewServer() *Server {
	return &Server{
		Basepath: "/rpc/",
		routes:   make(map[string]http.Handler),
		OnErr: func(w http.ResponseWriter, r *http.Request, err error) {
			errObj := struct {
				Error string `json:"error"`
			}{
				Error: err.Error(),
			}
			if err := encode(w, r, http.StatusInternalServerError, errObj); err != nil {
				log.Printf("failed to encode error: %s\n", err)
			}
		},
		NotFound: http.NotFoundHandler(),
	}
}

// Register adds a handler for the specified service method.
func (s *Server) Register(service, method string, h http.HandlerFunc) {
	s.routes[fmt.Sprintf("%s%s.%s", s.Basepath, service, method)] = h
}

// ServeHTTP serves the request.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		s.NotFound.ServeHTTP(w, r)
		return
	}
	h, ok := s.routes[r.URL.Path]
	if !ok {
		s.NotFound.ServeHTTP(w, r)
		return
	}
	h.ServeHTTP(w, r)
}

func encode(w http.ResponseWriter, r *http.Request, status int, v interface{}) error {
	b, err := json.Marshal(v)
	if err != nil {
		return fmt.Errorf("encode json: %w", err)
	}

	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(status)

	if _, err := w.Write(b); err != nil {
		return err
	}

	return nil
}

func decode(r *http.Request, v interface{}) error {
	body, err := io.ReadAll(io.LimitReader(r.Body, 1024*1024))
	if err != nil {
		return fmt.Errorf("decode: read body: %w", err)
	}

	err = json.Unmarshal(body, v)
	if err != nil {
		return fmt.Errorf("decode: json.Unmarshal: %w", err)
	}

	return nil
}

type Client struct {
	Endpoint      string
	HTTPClient    *http.Client
	BeforeRequest func(r *http.Request) error
}

func NewClient(endpoint string) *Client {
	c := &Client{
		Endpoint:   endpoint,
		HTTPClient: &http.Client{Timeout: 10 * time.Second},
	}
	return c
}

type ListClient struct {
	client *Client
}

// NewList makes a new client for accessing List services.
func NewListClient(client *Client) *ListClient {
	return &ListClient{
		client: client,
	}
}

func (s *ListClient) Add(ctx context.Context, r AddRequest) (*AddResponse, error) {
	data, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("%w: List.Add: marshal AddRequest", err)
	}

	rawurl := s.client.Endpoint + "List.Add"

	req, err := http.NewRequest(http.MethodPost, rawurl, bytes.NewReader(data))
	if err != nil {
		return nil, fmt.Errorf("%w: List.Add: NewRequest", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")

	req = req.WithContext(ctx)

	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}

	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("%w: List.Add", err)
	}
	defer resp.Body.Close()

	var response struct {
		AddResponse
		Error string
	}

	data, err = io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("%w: List.Add: read response body", err)
	}

	if err := json.Unmarshal(data, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("List.Add: (%d) %v", resp.StatusCode, string(data))
		}
		return nil, err
	}

	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}

	return &response.AddResponse, nil
}

func (s *ListClient) Clear(ctx context.Context, r ClearRequest) (*ClearResponse, error) {
	data, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("%w: List.Clear: marshal ClearRequest", err)
	}

	rawurl := s.client.Endpoint + "List.Clear"

	req, err := http.NewRequest(http.MethodPost, rawurl, bytes.NewReader(data))
	if err != nil {
		return nil, fmt.Errorf("%w: List.Clear: NewRequest", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")

	req = req.WithContext(ctx)

	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}

	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("%w: List.Clear", err)
	}
	defer resp.Body.Close()

	var response struct {
		ClearResponse
		Error string
	}

	data, err = io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("%w: List.Clear: read response body", err)
	}

	if err := json.Unmarshal(data, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("List.Clear: (%d) %v", resp.StatusCode, string(data))
		}
		return nil, err
	}

	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}

	return &response.ClearResponse, nil
}

func (s *ListClient) Items(ctx context.Context, r ItemsRequest) (*ItemsResponse, error) {
	data, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("%w: List.Items: marshal ItemsRequest", err)
	}

	rawurl := s.client.Endpoint + "List.Items"

	req, err := http.NewRequest(http.MethodPost, rawurl, bytes.NewReader(data))
	if err != nil {
		return nil, fmt.Errorf("%w: List.Items: NewRequest", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")

	req = req.WithContext(ctx)

	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}

	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("%w: List.Items", err)
	}
	defer resp.Body.Close()

	var response struct {
		ItemsResponse
		Error string
	}

	data, err = io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("%w: List.Items: read response body", err)
	}

	if err := json.Unmarshal(data, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("List.Items: (%d) %v", resp.StatusCode, string(data))
		}
		return nil, err
	}

	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}

	return &response.ItemsResponse, nil
}

func (s *ListClient) Remove(ctx context.Context, r RemoveRequest) (*RemoveResponse, error) {
	data, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("%w: List.Remove: marshal RemoveRequest", err)
	}

	rawurl := s.client.Endpoint + "List.Remove"

	req, err := http.NewRequest(http.MethodPost, rawurl, bytes.NewReader(data))
	if err != nil {
		return nil, fmt.Errorf("%w: List.Remove: NewRequest", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")

	req = req.WithContext(ctx)

	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}

	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("%w: List.Remove", err)
	}
	defer resp.Body.Close()

	var response struct {
		RemoveResponse
		Error string
	}

	data, err = io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("%w: List.Remove: read response body", err)
	}

	if err := json.Unmarshal(data, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("List.Remove: (%d) %v", resp.StatusCode, string(data))
		}
		return nil, err
	}

	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}

	return &response.RemoveResponse, nil
}
